{
  "hash": "a8c6382613d87b90f1a44a7a5b72079a",
  "result": {
    "markdown": "---\ntitle: \"Find Data: Programmatic Search\"\nexecute:\n  eval: false\n---\n\n\n## Introduction\n\nWe can find data programmatically using the following code.\n\n## Code\n\nHere are our recommended approaches for finding data with code.\n\n::: {.panel-tabset group=\"language\"}\n## Python\n\nIn Python we can use the [`earthdata`](https://earthdata.readthedocs.io/en/latest/) library (in development and to be renamed `earthaccess` very soon!)\n\nTo install the package we'll run this code from the command line. Note: you can run shell code directly from a Jupyter Notebook cell by adding a `!`, so it would be `!conda install`.\n\n\n::: {.cell filename='[command line code]'}\n\n```{.bash .cell-code}\n# Install earthdata\nconda install -c conda-forge earthdata\n```\n:::\n\n\nThis example searches for data from the [Land Processes DAAC](https://lpdaac.usgs.gov/) with a spatial bounding box. \n\n\n::: {.cell filename='[python code]'}\n\n```{.python .cell-code}\n## Import earthdata\nfrom earthdata import DataGranules\n\n# Then we build a Query with spatiotemporal parameters\nGranuleQuery = DataGranules().concept_id(\"C1575731655-LPDAAC_ECS\").bounding_box(-134.7,58.9,-133.9,59.2)\n\n# We get the metadata records from CMR, then view the output\ngranules = GranuleQuery.get()\ngranules\n```\n:::\n\n\n\n## R\n\nTo find data in R, we'll briefly make use of the `earthdata` python package - which we can do from R using the [`reticulate`](https://rstudio.github.io/reticulate/) package and [cheatsheet](https://www.rstudio.com/resources/cheatsheets/). You'll copy these code chunks into your RMarkdown or Quarto document: note that the second code chunk is in Python, but when you run them in sequence you'll be all set.\n\n\n::: {.cell filename='[R code]'}\n\n```{.r .cell-code}\n## load wrangling libraries\nlibrary(tidyverse) # install.packages(\"tidyverse\") \n\n## load reticulate and set up a python environment\nlibrary(reticulate) # install.packages(\"reticulate\")\nvirtualenv_create(\"earthdata-proj\")\npy_install(\"earthdata\", envname = \"earthdata-proj\")\nuse_virtualenv(\"earthdata-proj\")\n```\n:::\n\n\nNow, we'll use the `earthdata` python package. \n\n<!---note: would like to reuse the python chunk here with the same name, but currently can't with the language labeled\nhttps://bookdown.org/yihui/rmarkdown-cookbook/reuse-chunks.html\n--->\n\n\n::: {.cell filename='[python code]'}\n\n```{.python .cell-code}\n## Import earthdata\nfrom earthdata import DataGranules\n\n# Then we build a Query with spatiotemporal parameters\nGranuleQuery = DataGranules().concept_id(\"C1575731655-LPDAAC_ECS\").bounding_box(-134.7,58.9,-133.9,59.2)\n\n# We get the metadata records from CMR, then view the output\ngranules = GranuleQuery.get()\ngranules\n```\n:::\n\nNow we can access the `granules` python object in R using `reticulate`; note the `py$` syntax. We'll create an R object named `granules_r` and view it using `str`. \n\n\n::: {.cell filename='[R code]'}\n\n```{.r .cell-code}\ngranules_r <- py$granules\nstr(granules_r) %>% jsonlite::fromJSON()\n```\n:::\n\n\n## Matlab\n\nMatlab code coming soon!\n\n\n::: {.cell filename='[Matlab code]'}\n\n```{.bash .cell-code}\n# Coming soon!\n```\n:::\n\n\n## Command Line\n\nWith `wget` and `curl`:\n\n\n::: {.cell filename='[command line code]'}\n\n```{.bash .cell-code}\n# Coming soon!\n```\n:::\n\n\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}